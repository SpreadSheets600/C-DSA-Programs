{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"DSA Repository","text":""},{"location":"#contents","title":"Contents","text":"<ul> <li>July 24 - 2025 Programs [ Linear Search ]</li> <li>August 08 - 2025 Programs [ Stack Operations ]</li> <li>August 11 - 2025 Programs [ String Operations ]</li> </ul>"},{"location":"#notes","title":"Notes","text":"<ul> <li>Stack</li> <li>Linear Search</li> <li>Asymptotic Notation</li> </ul>"},{"location":"#resouces","title":"Resouces","text":"<ul> <li>Asymptotic Notation</li> </ul>"},{"location":"#how-to-use","title":"How to Use","text":"<ol> <li>Navigate to the date folder for the specific session you're interested in</li> <li>View the markdown file (e.g., <code>24-07-25/README.md</code>) for instructions and questions</li> <li>Check the corresponding <code>.cpp</code> files for the solutions</li> </ol>"},{"location":"#getting-started","title":"Getting Started","text":"<p>To compile any program in this repository:</p> <pre><code>gcc  program.cpp\na.exe # Or ./a.out\n</code></pre>"},{"location":"#to-run-in-turbo-c","title":"To Run In Turbo C++","text":"<p>Just make the following cahnges in the code</p> <pre><code>int mian() -&gt; void main()\n</code></pre> <pre><code>return 0; -&gt; getch();\n</code></pre>"},{"location":"04-08-2025/","title":"Programming Exercises - August 08, 2025","text":""},{"location":"04-08-2025/#exercise-1-global-stack-operations","title":"Exercise 1 : Global Stack Operations","text":"<p>Qestion: Write a program to perform operations of stack.</p> <p>Sollution: View Code</p> <pre><code>#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n#define MAX 3\n\nint stack[MAX];\nint top = -1;\n\nint isfull()\n{\n    if (top == MAX - 1)\n    {\n        return 1;\n    }\n    else\n    {\n        return 0;\n    }\n}\n\nint isempty()\n{\n    if (top == -1)\n    {\n        return 1;\n    }\n    else\n    {\n        return 0;\n    }\n}\n\nvoid push()\n{\n    int x, m;\n    m = isfull();\n\n    if (m == 1)\n    {\n        printf(\"Stack Overflow\\n\");\n    }\n    else\n    {\n        printf(\"Enter The Element To Push : \");\n        scanf(\"%d\", &amp;x);\n\n        top++;\n        stack[top] = x;\n\n        printf(\"%d Pushed To Stack\\n\", x);\n    }\n}\n\nvoid pop()\n{\n    int item, m;\n\n    m = isempty();\n\n    if (m == 1)\n    {\n        printf(\"Stack Underflow\\n\");\n    }\n    else\n    {\n        int item = stack[top];\n        top--;\n\n        printf(\"Popped Element %d\\n\", item);\n    }\n}\n\nvoid display()\n{\n    int i;\n    printf(\"Displaying Stack : \\n\");\n\n    for (int i = top; i &gt;= 0; i--)\n    {\n        printf(\"%d \", stack[i]);\n    }\n    printf(\"\\n\");\n}\n\nint main()\n{\n    int choise, m;\n\n    while (1)\n    {\n        printf(\"\\n*** Stack Menu ***\");\n        printf(\"\\n\\n1. Check If Empty\\n2. Check If Full\\n3. Push\\n4. Pop\\n5. Display\\n6. Exit\");\n        printf(\"\\n\\nEnter Your Choise (1 - 6) : \");\n        scanf(\"%d\", &amp;choise);\n\n        switch (choise)\n        {\n        case 1:\n            m = isempty();\n\n            if (m == 1)\n            {\n                printf(\"\\nStack Is Empty\\n\");\n            }\n            break;\n\n        case 2:\n            m = isfull();\n\n            if (m == 1)\n            {\n                printf(\"\\nStack Is Full\\n\");\n            }\n            else\n            {\n                printf(\"\\nStack Is Not Full\\n\");\n            }\n            break;\n\n        case 3:\n            push();\n            break;\n\n        case 4:\n            pop();\n            break;\n\n        case 5:\n            display();\n            break;\n\n        case 6:\n            exit(0);\n\n        default:\n            printf(\"\\nWrong Choice\");\n        }\n    }\n    return 0;\n}\n</code></pre>"},{"location":"04-08-2025/#output-1","title":"OUTPUT 1","text":"<pre><code>*** Stack Menu ***\n\n1. Check If Empty\n2. Check If Full\n3. Push\n4. Pop\n5. Display\n6. Exit\n\nEnter Your Choise (1 - 6) : 3\nEnter The Element To Push : 4\n4 Pushed To Stack\n\n*** Stack Menu ***\n\n1. Check If Empty\n2. Check If Full\n3. Push\n4. Pop\n5. Display\n6. Exit\n\nEnter Your Choise (1 - 6) : 3\nEnter The Element To Push : 5\n5 Pushed To Stack\n\n*** Stack Menu ***\n\n1. Check If Empty\n2. Check If Full\n3. Push\n4. Pop\n5. Display\n6. Exit\n\nEnter Your Choise (1 - 6) : 3\nEnter The Element To Push : 6\n6 Pushed To Stack\n\n*** Stack Menu ***\n\n1. Check If Empty\n2. Check If Full\n3. Push\n4. Pop\n5. Display\n6. Exit\n\nEnter Your Choise (1 - 6) : 5\nDisplaying Stack : \n6 5 4 \n\n*** Stack Menu ***\n\n1. Check If Empty\n2. Check If Full\n3. Push\n4. Pop\n5. Display\n6. Exit\n\nEnter Your Choise (1 - 6) : 4\nPopped Element 6\n\n*** Stack Menu ***\n\n1. Check If Empty\n2. Check If Full\n3. Push\n4. Pop\n5. Display\n6. Exit\n\nEnter Your Choise (1 - 6) : 6\n</code></pre>"},{"location":"04-08-2025/#exercise-2-local-stack-operations","title":"Exercise 2 : Local Stack Operations","text":"<p>Qestion: Write a program to perform operations of stack.</p> <p>Sollution: View Code</p> <pre><code># include &lt;stdlib.h&gt;  \n# include &lt;stdio.h&gt;  \n\nint isfull(int top, int max)\n{\n    if (top == max - 1)\n    {\n        return 1;\n    }\n    else\n    {\n        return 0;\n    }\n}\n\n\nint isempty(int top)\n{\n    if (top == -1)\n    {\n        return 1;\n    }\n    else\n    {\n        return 0;\n    }\n}\n\nvoid push(int *top, int max, int stack[]) {\n    int x;\n\n    if (isfull(*top, max)) {\n        printf(\"Stack Overflow\\n\");\n\n    } else {\n        printf(\"Enter The Element To Push : \");\n        scanf(\"%d\", &amp;x);\n\n        (*top)++; \n        stack[*top] = x;\n\n        printf(\"%d Pushed To Stack\\n\", x);\n    }\n}\n\nvoid pop(int *top, int stack[]) {\n    int item;\n\n    if (isempty(*top)) {\n        printf(\"Stack Underflow\\n\");\n\n    } else {\n        item = stack[*top];\n        (*top)--; \n\n        printf(\"Popped Element %d\\n\", item);\n    }\n}\n\nvoid display(int top, int stack[])\n{\n    int i;\n    printf(\"Displaying Stack : \\n\");\n\n    if (isempty(top))\n    {\n        printf(\"Stack Is Empty\\n\");\n        return;\n    }\n\n    for (i = top; i &gt;= 0; i--)\n    {\n        printf(\"%d \", stack[i]);\n    }\n    printf(\"\\n\");\n}\n\n\nint main()\n{\n    int choise, m, max;\n\n    printf(\"Enter The Max Size Of Stack : \");\n    scanf(\"%d\", &amp;max);\n\n    int stack[max];\n    int top = -1;\n\n    while (1)\n    {\n        printf(\"\\n*** Stack Menu ***\");\n        printf(\"\\n\\n1. Check If Empty\\n2. Check If Full\\n3. Push\\n4. Pop\\n5. Display\\n6. Exit\");\n        printf(\"\\n\\nEnter Your Choise (1 - 6) : \");\n        scanf(\"%d\", &amp;choise);\n\n        switch (choise)\n        {\n        case 1:\n            m = isempty(top);\n\n            if (m == 1)\n            {\n                printf(\"\\nStack Is Empty\\n\");\n            }\n            else\n            {\n                printf(\"\\nStack Is Not Empty\\n\");\n            }\n            break;\n\n        case 2:\n            m = isfull(top, max);\n\n            if (m == 1)\n            {\n                printf(\"\\nStack Is Full\\n\");\n            }\n            else\n            {\n                printf(\"\\nStack Is Not Full\\n\");\n            }\n            break;\n\n        case 3:\n            push(&amp;top, max, stack);\n            break;\n\n        case 4:\n            pop(&amp;top, stack);\n            break;\n\n        case 5:\n            display(top, stack);\n            break;\n\n        case 6:\n            exit(0);\n\n        default:\n            printf(\"\\nWrong Choice\\n\");\n        }\n    }\n    return 0;\n}\n</code></pre>"},{"location":"04-08-2025/#output-2","title":"OUTPUT 2","text":"<pre><code>Enter The Max Size Of Stack : 3\n\n*** Stack Menu ***\n\n1. Check If Empty\n2. Check If Full\n3. Push\n4. Pop\n5. Display\n6. Exit\n\nEnter Your Choise (1 - 6) : 3\nEnter The Element To Push : 4\n4 Pushed To Stack\n\n*** Stack Menu ***\n\n1. Check If Empty\n2. Check If Full\n3. Push\n4. Pop\n5. Display\n6. Exit\n\nEnter Your Choise (1 - 6) : 3\nEnter The Element To Push : 5\n5 Pushed To Stack\n\n*** Stack Menu ***\n\n1. Check If Empty\n2. Check If Full\n3. Push\n4. Pop\n5. Display\n6. Exit\n\nEnter Your Choise (1 - 6) : 3\nEnter The Element To Push : 6\n6 Pushed To Stack\n\n*** Stack Menu ***\n\n1. Check If Empty\n2. Check If Full\n3. Push\n4. Pop\n5. Display\n6. Exit\n\nEnter Your Choise (1 - 6) : 5\nDisplaying Stack : \n6 5 4 \n\n*** Stack Menu ***\n\n1. Check If Empty\n2. Check If Full\n3. Push\n4. Pop\n5. Display\n6. Exit\n\nEnter Your Choise (1 - 6) : 4\nPopped Element 6\n\n*** Stack Menu ***\n\n1. Check If Empty\n2. Check If Full\n3. Push\n4. Pop\n5. Display\n6. Exit\n\nEnter Your Choise (1 - 6) : 6\n</code></pre>"},{"location":"11-08-2025/","title":"Programming Exercises - August 11, 2025","text":""},{"location":"11-08-2025/#exercise-1-string-operations","title":"Exercise 1 : String Operations","text":"<p>Qestion: Write a single program in c with menu facility to perform the following string operations :</p> <pre><code>            1. String Length\n\n            2. String Reverse\n\n            3. String Concatenation\n\n            4. String Compare\n\n            5. Search A Character Within A String\n</code></pre> <p>Sollution: View Code</p> <pre><code>#include &lt;stdio.h&gt;\n\n// Loop With Counter\nint stringLength(char *str)\n{\n    int len = 0;\n    while (str[len] != '\\0')\n    {\n        len++;\n    }\n    return len;\n}\n\n// Loop And Swap The Values Using Temp\nvoid stringReverse(char *str)\n{\n    int len = stringLength(str);\n    int i, j;\n    char temp;\n\n    for (i = 0, j = len - 1; i &lt; j; i++, j--)\n    {\n        temp = str[i];\n        str[i] = str[j];\n        str[j] = temp;\n    }\n}\n\n// Run Two Loops And Check\nvoid stringConcatenate(char *dest, char *src)\n{\n    int i = 0, j = 0;\n\n    while (dest[i] != '\\0')\n    {\n        i++;\n    }\n\n    while (src[j] != '\\0')\n    {\n        dest[i] = src[j];\n        i++;\n        j++;\n    }\n\n    dest[i] = '\\0';\n}\n\n// Search Each With A loop\nint stringCompare(char *str1, char *str2)\n{\n    int i = 0;\n\n    while (str1[i] != '\\0' &amp;&amp; str2[i] != '\\0')\n    {\n        if (str1[i] != str2[i])\n        {\n            return 0;\n        }\n        i++;\n    }\n\n    return (str1[i] == '\\0' &amp;&amp; str2[i] == '\\0');\n}\n\n// Linear Search Loop\nint searchCharacter(char *str, char ch)\n{\n    int i = 0;\n\n    while (str[i] != '\\0')\n    {\n        if (str[i] == ch)\n        {\n            return i;\n        }\n        i++;\n    }\n    return -1;\n}\n\nint main()\n{\n    int choice;\n    char str1[100], str2[100];\n    char ch;\n    int index;\n\n    do\n    {\n        printf(\"\\n\\n*** String Operations Menu ***\\n\");\n        printf(\"1. String Length\\n\");\n        printf(\"2. String Reverse\\n\");\n        printf(\"3. String Concatenation\\n\");\n        printf(\"4. String Compare\\n\");\n        printf(\"5. Character Search\\n\");\n        printf(\"6. Exit\\n\");\n        printf(\"Enter Your Choice (1 - 6): \");\n        scanf(\"%d\", &amp;choice);\n\n        switch (choice)\n        {\n        case 1:\n            printf(\"Enter A String : \");\n            scanf(\"%s\", str1);\n\n            printf(\"The Length Of String : %d\\n\", stringLength(str1));\n            break;\n\n        case 2:\n            printf(\"Enter String To Reverse : \");\n            scanf(\"%s\", str1);\n\n            stringReverse(str1);\n\n            printf(\"Reversed String : %s\\n\", str1);\n            break;\n\n        case 3:\n            printf(\"Enter First String : \");\n            scanf(\"%s\", str1);\n\n            printf(\"Enter Second String : \");\n            scanf(\"%s\", str2);\n\n            stringConcatenate(str1, str2);\n\n            printf(\"Concatenated String : %s\\n\", str1);\n            break;\n\n        case 4:\n            printf(\"Enter First String : \");\n            scanf(\"%s\", str1);\n\n            printf(\"Enter Second String : \");\n            scanf(\"%s\", str2);\n\n            if (stringCompare(str1, str2))\n            {\n                printf(\"The Stings Not Equal.\\n\");\n            }\n            else\n            {\n                printf(\"The Strings Are Not Euqal\\n\");\n            }\n            break;\n\n        case 5:\n            printf(\"Enter A String : \");\n            scanf(\"%s\", str1);\n\n            printf(\"Enter A Character To Search : \");\n            scanf(\" %c\", &amp;ch);\n\n            index = searchCharacter(str1, ch);\n\n            if (index != -1)\n            {\n                printf(\"Character '%c' Found At %d\\n\", ch, index);\n            }\n            else\n            {\n                printf(\"Character '%c' Not Found\\n\", ch);\n            }\n            break;\n\n        case 6:\n            printf(\"Exiting Program\\n\");\n            break;\n\n        default:\n            printf(\"Invalid Choise\\n\");\n        }\n\n    } while (choice != 6);\n\n    return 0;\n}\n</code></pre>"},{"location":"11-08-2025/#output-1","title":"OUTPUT 1","text":"<pre><code>*** String Operations Menu ***\n1. String Length\n2. String Reverse\n3. String Concatenation\n4. String Compare\n5. Character Search\n6. Exit\nEnter Your Choice (1 - 6): 1\nEnter A String : SOHAM\nThe Length Of String : 5\n\n\n*** String Operations Menu ***\n1. String Length\n2. String Reverse\n3. String Concatenation\n4. String Compare\n5. Character Search\n6. Exit\nEnter Your Choice (1 - 6): 2\nEnter String To Reverse : SOHAM\nReversed String : MAHOS\n\n\n*** String Operations Menu ***\n1. String Length\n2. String Reverse\n3. String Concatenation\n4. String Compare\n5. Character Search\n6. Exit\nEnter Your Choice (1 - 6): 3\nEnter First String : SO\nEnter Second String : HAM\nConcatenated String : SOHAM\n\n\n*** String Operations Menu ***\n1. String Length\n2. String Reverse\n3. String Concatenation\n4. String Compare\n5. Character Search\n6. Exit\nEnter Your Choice (1 - 6): 4\nEnter First String : SOHAM\nEnter Second String : Soham\nThe Strings Are Not Euqal\n\n\n*** String Operations Menu ***\n1. String Length\n2. String Reverse\n3. String Concatenation\n4. String Compare\n5. Character Search\n6. Exit\nEnter Your Choice (1 - 6): 5\nEnter A String : SOHAM\nEnter A Character To Search : H\nCharacter 'H' Found At 2\n\n\n*** String Operations Menu ***\n1. String Length\n2. String Reverse\n3. String Concatenation\n4. String Compare\n5. Character Search\n6. Exit\nEnter Your Choice (1 - 6): 6\nExiting Program\n</code></pre>"},{"location":"24-07-2025/","title":"Programming Exercises - July 24, 2025","text":""},{"location":"24-07-2025/#exercise-1-staic-liner-search","title":"Exercise 1 : Staic Liner Search","text":"<p>Qestion: Write a program to perform liner search using static memory allocation.</p> <p>Sollution: View Code</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint linerSearch(int arr[100], int n, int key)\n{\n    for (int i = 0; i &lt; n; i++)\n    {\n        if (arr[i] == key)\n        {\n            return i;\n        }\n    }\n\n    return -1;\n}\n\nint main()\n{\n    int n, key, arr[100];\n\n    printf(\"Enter The Number Of Elements : \");\n    scanf(\"%d\", &amp;n);\n\n    for (int i = 0; i &lt; n; i++)\n    {\n        printf(\"Enter The Element %d : \", i + 1);\n        scanf(\"%d\", &amp;arr[i]);\n    }\n\n    printf(\"Enter The Key To Be Searched : \");\n    scanf(\"%d\", &amp;key);\n\n    int index = linerSearch(arr, n, key);\n\n    if (index != 1)\n    {\n        printf(\"Element Found At Index : %d\\n\", index);\n    }\n    else\n    {\n        printf(\"Element Not Found\\n\");\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"24-07-2025/#output-1","title":"OUTPUT 1","text":"<pre><code>Enter The Number Of Elements : 3\nEnter The Element 1 : 2\nEnter The Element 2 : 6\nEnter The Element 3 : 9\nEnter The Key To Be Searched : 9\nElement Found At Index : 2\n</code></pre>"},{"location":"24-07-2025/#exercise-2-dynamic-linear-search","title":"Exercise 2 : Dynamic Linear Search","text":"<p>Qestion: Write a program to perform liner search using dynamic memory allocation.</p> <p>Sollution 1: View Code Sollution 2: View Code</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint linerSearch(int *arr, int n, int key)\n{\n    for (int i = 0; i &lt; n; i++)\n    {\n        if (arr[i] == key)\n        {\n            return i;\n        }\n    }\n\n    return -1;\n}\n\nint main()\n{\n    int n, key, *arr;\n\n    printf(\"Enter The Number Of Elements : \");\n    scanf(\"%d\", &amp;n);\n\n    arr = (int *)malloc(n * sizeof(int));\n\n    for (int i = 0; i &lt; n; i++)\n    {\n        printf(\"Enter The Element %d : \", i + 1);\n        scanf(\"%d\", &amp;arr[i]);\n    }\n\n    printf(\"Enter The Key To Be Searched : \");\n    scanf(\"%d\", &amp;key);\n\n    int index = linerSearch(arr, n, key);\n\n    if (index != -1)\n    {\n        printf(\"Element Found At Index : %d\\n\", index);\n    }\n    else\n    {\n        printf(\"Element Not Found\\n\");\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"24-07-2025/#output-2","title":"OUTPUT 2","text":"<pre><code>Enter The Number Of Elements : 3\nEnter The Element 1 : 4\nEnter The Element 2 : 5\nEnter The Element 3 : 6\nEnter The Key To Be Searched : 5\nElement Found At Index : 1\n</code></pre>"},{"location":"Notes/AsymptoticNotation/","title":"Asymptotic Notations","text":""},{"location":"Notes/AsymptoticNotation/#what-is-asymptotic-notation","title":"What is Asymptotic Notation?","text":"<p>Imagine you\u2019re trying to see how fast an algorithm is as your input size grows. You don\u2019t care about small details like:</p> <ul> <li>The brand of your CPU</li> <li>Whether you used <code>i++</code> or <code>i += 1</code></li> <li>Exact number of milliseconds</li> </ul> <p>Instead, you want to know: \ud83d\udca1 \u201cWhat happens when my input gets HUGE?\u201d</p> <p>That\u2019s where asymptotic notation comes in. It\u2019s like short-hand math for describing growth rates of algorithms.</p>"},{"location":"Notes/AsymptoticNotation/#why-do-we-need-it","title":"Why do we need it?","text":"<ol> <li>Ignore constants and small terms \u2014 focus on the big picture.</li> <li>Compare algorithms fairly \u2014 across different machines.</li> <li>Predict scalability \u2014 how well will it handle massive input.</li> </ol> <p>Example:</p> <ul> <li>Algorithm A takes <code>0.05n\u00b2 + 2n + 3</code> operations.</li> <li>Algorithm B takes <code>100n + 10</code> operations.</li> </ul> <p>For small <code>n</code>, B might be slower due to the big constant <code>100</code>. But as <code>n</code> grows, <code>n\u00b2</code> will crush <code>n</code>, so A will eventually be much slower.</p>"},{"location":"Notes/AsymptoticNotation/#the-main-asymptotic-notations","title":"The Main Asymptotic Notations","text":"<p>There are five primary notations you\u2019ll see often.</p>"},{"location":"Notes/AsymptoticNotation/#big-o-upper-bound","title":"Big O \u2014 Upper Bound","text":"<p>Definition: Describes the worst-case growth rate. It tells you: \u201cIt won\u2019t grow faster than this.\u201d</p> <p>Formal idea:</p> <pre><code>f(n) = O(g(n))  means  f(n) \u2264 C \u00d7 g(n)   for some constant C, for large enough n.\n</code></pre> <p>Example: If an algorithm takes <code>3n + 2</code> steps, then it\u2019s O(n). It won\u2019t ever grow faster than some multiple of <code>n</code>.</p> <p>You use Big O for:</p> <ul> <li>Worst-case runtime (common in competitive programming).</li> <li>Space complexity upper bound.</li> </ul>"},{"location":"Notes/AsymptoticNotation/#big-omega-lower-bound","title":"Big Omega (\u03a9) \u2014 Lower Bound","text":"<p>Definition: Describes the best-case growth rate. It says: \u201cIt will take at least this much time.\u201d</p> <p>Formal idea:</p> <pre><code>f(n) = \u03a9(g(n))  means  f(n) \u2265 C \u00d7 g(n)   for some constant C, for large enough n.\n</code></pre> <p>Example: If you must check every element at least once, best case is \u03a9(n).</p>"},{"location":"Notes/AsymptoticNotation/#big-theta-tight-bound","title":"Big Theta (\u0398) \u2014 Tight Bound","text":"<p>Definition: Describes an exact growth rate. It says: \u201cIt grows at this rate, no faster, no slower (asymptotically).\u201d</p> <p>Formal idea:</p> <pre><code>f(n) = \u0398(g(n))  means  it\u2019s both O(g(n)) and \u03a9(g(n)).\n</code></pre> <p>Example: <code>5n + 3</code> is \u0398(n) because:</p> <ul> <li>Upper bound is O(n)</li> <li>Lower bound is \u03a9(n)</li> </ul> <p>Think: \u0398 is like pinning it down exactly.</p>"},{"location":"Notes/AsymptoticNotation/#little-o-strictly-less-than","title":"Little o \u2014 Strictly Less Than","text":"<p>Definition: Describes that a function grows strictly slower than another.</p> <p>Formal idea:</p> <pre><code>f(n) = o(g(n))  means  f(n) grows slower than g(n), and ratio \u2192 0 as n \u2192 \u221e.\n</code></pre> <p>Example: <code>n</code> is <code>o(n\u00b2)</code> because as n grows, <code>n / n\u00b2 = 1/n \u2192 0</code>.</p>"},{"location":"Notes/AsymptoticNotation/#little-omega-strictly-greater-than","title":"Little omega \u2014 Strictly Greater Than","text":"<p>Definition: Opposite of little o. Function grows strictly faster.</p> <p>Formal idea:</p> <pre><code>f(n) = \u03c9(g(n))  means  f(n) grows faster than g(n), and ratio \u2192 \u221e as n \u2192 \u221e.\n</code></pre> <p>Example: <code>n\u00b2</code> is <code>\u03c9(n)</code> because <code>n\u00b2 / n = n \u2192 \u221e</code>.</p> <p></p>"},{"location":"Notes/AsymptoticNotation/#order-of-growth-cheat-sheet","title":"Order of Growth Cheat Sheet","text":"<p>From slowest to fastest (common ones):</p> Growth Rate Name Example O(1) Constant time Access array element O(log n) Logarithmic Binary search O(n) Linear Loop through array O(n log n) Log-linear Merge sort O(n\u00b2) Quadratic Nested loops O(n\u00b3) Cubic Triple nested loops O(2\u207f) Exponential Naive recursive Fibonacci O(n!) Factorial Traveling salesman brute-force"},{"location":"Notes/AsymptoticNotation/#dropping-constants-lower-order-terms","title":"Dropping Constants &amp; Lower-Order Terms","text":"<p>When writing Big O, we only care about the dominant term as <code>n \u2192 \u221e</code>.</p> <p>Example: <code>T(n) = 3n\u00b2 + 10n + 5</code> \u2192 O(n\u00b2) Because:</p> <ul> <li><code>n\u00b2</code> dominates for large <code>n</code></li> <li>Constants (3, 10, 5) don\u2019t matter.</li> </ul>"},{"location":"Notes/AsymptoticNotation/#best-worst-and-average-cases","title":"Best, Worst, and Average Cases","text":"<ul> <li>Best case \u2192 Often given in \u03a9 notation.</li> <li>Worst case \u2192 Often given in O notation.</li> <li>Average case \u2192 Can also use \u0398 notation.</li> </ul> <p>Example: Linear search in an array of size <code>n</code>:</p> <ul> <li>Best case (element at start) \u2192 \u03a9(1)</li> <li>Worst case (element at end or absent) \u2192 O(n)</li> <li>Average case \u2192 \u0398(n)</li> </ul>"},{"location":"Notes/AsymptoticNotation/#graphical-intuition","title":"Graphical Intuition","text":"<p>If we plotted time vs input size:</p> <ul> <li>O(n) \u2192 straight upward slope</li> <li>O(log n) \u2192 rises quickly at first, then flattens</li> <li>O(n\u00b2) \u2192 curve gets steep fast</li> <li>O(2\u207f) \u2192 skyrockets almost immediately</li> </ul>"},{"location":"Notes/AsymptoticNotation/#quick-summary-table","title":"Quick Summary Table","text":"Notation Meaning Says What? Example O(g(n)) Upper bound Worst-case O(n\u00b2) \u03a9(g(n)) Lower bound Best-case \u03a9(n) \u0398(g(n)) Tight bound Exact asymptotic behavior \u0398(n) o(g(n)) Strictly less Grows slower o(n\u00b2) \u03c9(g(n)) Strictly more Grows faster \u03c9(n)"},{"location":"Notes/LinearSearch/","title":"Linear Search","text":"<p>In Linear Search, we iterate over all the elements of the array and check if it the current element is equal to the target element. If we find any element to be equal to the target element, then return the index of the current element. Otherwise, if no element is equal to the target element, then return -1 as the element is not found. Linear search is also known as sequential search.</p>"},{"location":"Notes/LinearSearch/#visualization","title":"Visualization","text":""},{"location":"Notes/LinearSearch/#time-complexity","title":"Time Complexity","text":"Case Time Complexity Best Case O(1) Average Case O(n) Worst Case O(n) <p>Where n is the number of elements in the array.</p>"},{"location":"Notes/LinearSearch/#space-complexity","title":"Space Complexity","text":"Case Space Complexity All Cases O(1) <p>Linear search uses a constant amount of extra space regardless of the input size.</p>"},{"location":"Notes/Stack/","title":"Stack","text":"<p>Stack is the linear data structure that follows the Last in, First Out(LIFO) principle of data insertion and deletion. It means that the element that is inserted last will be the first one to be removed and the element that is inserted first will be removed at last. Think of it as the stack of plates stacked on top of one another where we can only add or remove the top plate.</p>"},{"location":"Notes/Stack/#stack-is-fist-in-first-out-fifo","title":"Stack Is Fist In First Out ( FIFO )","text":""},{"location":"Notes/Stack/#visualization","title":"Visualization","text":""},{"location":"Notes/Stack/#operations","title":"Operations","text":"<ul> <li>Is Full: Check if the stack is full.</li> <li>Is Empty: Check if the stack is empty.</li> <li>Pop: Remove the top element from the stack.</li> <li>Push: Add an element to the top of the stack.</li> <li>Display: Display all the elements in the stack.</li> <li>Peek: Get the top element of the stack without removing it.</li> </ul>"},{"location":"Notes/Stack/#time-complexity","title":"Time Complexity","text":"Operation Time Complexity Is Full O(1) Is Empty O(1) Pop O(1) Push O(1) Display O(n) Peek O(1) <p>Where n is the number of elements in the stack.</p>"}]}