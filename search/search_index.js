var __index = {"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"DSA Repository","text":""},{"location":"index.html#contents","title":"Contents","text":"<ul> <li>July 24 - 2025 Programs [ Linear Search ]</li> <li>August 08 - 2025 Programs [ Stack Operations ]</li> <li>August 11 - 2025 Programs [ String Operations ]</li> <li>August 18 - 2025 Programs [ Linked List Operations ]</li> </ul>"},{"location":"index.html#notes","title":"Notes","text":"<ul> <li>Stack</li> <li>Linear Search</li> <li>Asymptotic Notation</li> </ul>"},{"location":"index.html#resouces","title":"Resouces","text":"<ul> <li>Asymptotic Notation</li> </ul>"},{"location":"index.html#how-to-use","title":"How to Use","text":"<ol> <li>Navigate to the date folder for the specific session you're interested in</li> <li>View the markdown file (e.g., <code>24-07-25/README.md</code>) for instructions and questions</li> <li>Check the corresponding <code>.cpp</code> files for the solutions</li> </ol>"},{"location":"index.html#getting-started","title":"Getting Started","text":"<p>To compile any program in this repository:</p> <pre><code>gcc  program.cpp\na.exe # Or ./a.out\n</code></pre>"},{"location":"index.html#to-run-in-turbo-c","title":"To Run In Turbo C++","text":"<p>Just make the following cahnges in the code</p> <pre><code>int mian() -&gt; void main()\n</code></pre> <pre><code>return 0; -&gt; getch();\n</code></pre>"},{"location":"BubbleSort.html","title":"BubbleSort.cpp","text":"<pre><code>#include &lt;stdbool.h&gt;\n#include &lt;stdio.h&gt;\n\nvoid swap(int *xp, int *yp)\n{\n    int temp = *xp;\n    *xp = *yp;\n    *yp = temp;\n}\n\nvoid bubbleSort(int arr[], int n)\n{\n    int i, j;\n    bool swapped;\n\n    for (i = 0; i &lt; n - 1; i++)\n    {\n        swapped = false;\n\n        for (j = 0; j &lt; n - i - 1; j++)\n        {\n            if (arr[j] &gt; arr[j + 1])\n            {\n                swap(&amp;arr[j], &amp;arr[j + 1]);\n                swapped = true;\n            }\n        }\n\n        if (swapped == false)\n            break;\n    }\n}\n\nvoid printArray(int arr[], int size)\n{\n    int i;\n\n    for (i = 0; i &lt; size; i++)\n        printf(\"%d \", arr[i]);\n}\n\nint main()\n{\n    int arr[] = {64, 34, 25, 12, 22, 11, 90};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    bubbleSort(arr, n);\n\n    printf(\"Sorted Array : \\n\");\n    printArray(arr, n);\n\n    return 0;\n}\n</code></pre>"},{"location":"LinkedList.html","title":"LinkedList.cpp","text":"<pre><code>#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n\nstruct Node\n{\n    int data;\n    struct Node *next;\n};\n\nstruct Node *Head = NULL, *Last = NULL;\n\nvoid createNode()\n{\n    struct Node *newNode = (struct Node *)malloc(sizeof(struct Node));\n\n    printf(\"\\n Enter Data\");\n    scanf(\"%d\", &amp;newNode-&gt;data); // Since We Are Using Pointers\n\n    newNode-&gt;next = NULL;\n\n    if (Head == NULL)\n    {\n        Head = newNode;\n        Last = newNode;\n    }\n    else\n    {\n        Last-&gt;next = newNode;\n        Last = newNode;\n    }\n}\n\nvoid displayList()\n{\n    struct Node *newNode = Head; // Copying Address Of Head To newNode, Cause Head Pointer Should Not Be Changed\n\n    while (newNode != NULL)\n    {\n        printf(\"\\n%d \", newNode-&gt;data);\n        newNode = newNode-&gt;next;\n    }\n}\n\nvoid deleteNode()\n{\n    if (Head == NULL)\n    {\n        printf(\"\\nList is Empty\");\n        return;\n    }\n\n    struct Node *temp = Head;\n    Head = Head-&gt;next;\n    free(temp);\n\n    if (Head == NULL)\n    {\n        Last = NULL; // If The List Becomes Empty\n    }\n}\n\nint main()\n{\n    int choice;\n\n    while (1)\n    {\n        printf(\"\\n\\n1. Create Node\\n2. Display List\\n3. Delete Node\\n4. Exit\\n\");\n        printf(\"Enter Your Choice: \");\n        scanf(\"%d\", &amp;choice);\n\n        switch (choice)\n        {\n        case 1:\n            createNode();\n            break;\n        case 2:\n            displayList();\n            break;\n        case 3:\n            deleteNode();\n            break;\n        case 4:\n            exit(0);\n        default:\n            printf(\"\\nInvalid Choice\");\n        }\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"TreesArray.html","title":"TreesArray.cpp","text":"<pre><code>#include &lt;stdio.h&gt;\n#define MAX 100\n\nint tree[MAX];\nint size = 0;\n\n// Insert Into Array Tree\nvoid insert(int value)\n{\n    if (size &gt;= MAX)\n    {\n        printf(\"Tree is full!\\n\");\n        return;\n    }\n    tree[size++] = value;\n}\n\n// Print Tree In Level Order\nvoid printTree()\n{\n    printf(\"Tree: \");\n    for (int i = 0; i &lt; size; i++)\n    {\n        printf(\"%d \", tree[i]);\n    }\n    printf(\"\\n\");\n}\n\n// Get Parent Index\nint getParentIndex(int index)\n{\n    if (index == 0)\n        return -1;\n\n    return (index - 1) / 2;\n}\n\n// Get Left Child Index\nint getLeftChildIndex(int index)\n{\n    return 2 * index + 1;\n}\n\n// Get Right Child Index\nint getRightChildIndex(int index)\n{\n    return 2 * index + 2;\n}\n\n// Get Parent Value\nint getParentValue(int index)\n{\n    int parentIndex = getParentIndex(index);\n    if (parentIndex == -1)\n        return -1;\n\n    return tree[parentIndex];\n}\n\n// Get Left Child Value\nint getLeftChildValue(int index)\n{\n    int leftChildIndex = getLeftChildIndex(index);\n    if (leftChildIndex &gt;= size)\n        return -1;\n\n    return tree[leftChildIndex];\n}\n\n// Get Right Child Value\nint getRightChildValue(int index)\n{\n    int rightChildIndex = getRightChildIndex(index);\n    if (rightChildIndex &gt;= size)\n        return -1;\n\n    return tree[rightChildIndex];\n}\n\n// Get Value At Index\nint getValueAtIndex(int index)\n{\n    if (index &lt; 0 || index &gt;= size)\n        return -1;\n\n    return tree[index];\n}\n\n// Get Size Of Tree\nint getHeight()\n{\n    return size;\n}\n\n// Check If Tree Is Empty\nint isEmpty()\n{\n    return size == 0;\n}\n\nint main()\n{\n    printf(\"*** Array Tree ***\\n\\n\");\n    insert(10);\n    insert(20);\n    insert(30);\n    insert(40);\n    insert(50);\n\n    printTree();\n\n    int index = 2;\n    printf(\"Parent Of %d : %d\\n\", tree[index], getParentValue(index));\n    printf(\"Left Child Of %d : %d\\n\", tree[index], getLeftChildValue(index));\n    printf(\"Right Child Of %d : %d\\n\\n\", tree[index], getRightChildValue(index));\n\n    printf(\"Value At Index 3 : %d\\n\", getValueAtIndex(3));\n    printf(\"Height Of Tree : %d\\n\\n\", getHeight());\n\n    printf(\"Is Tree Empty ? %s\\n\", isEmpty() ? \"Yes\" : \"No\");\n    return 0;\n}\n</code></pre>"},{"location":"04-08-2025/index.html","title":"Programming Exercises - August 08, 2025","text":""},{"location":"04-08-2025/index.html#exercise-1-global-stack-operations","title":"Exercise 1 : Global Stack Operations","text":"<p>Qestion: Write a program to perform operations of stack.</p> <p>Sollution: View Code</p> <pre><code>#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n#define MAX 3\n\nint stack[MAX];\nint top = -1;\n\nint isfull()\n{\n    if (top == MAX - 1)\n    {\n        return 1;\n    }\n    else\n    {\n        return 0;\n    }\n}\n\nint isempty()\n{\n    if (top == -1)\n    {\n        return 1;\n    }\n    else\n    {\n        return 0;\n    }\n}\n\nvoid push()\n{\n    int x, m;\n    m = isfull();\n\n    if (m == 1)\n    {\n        printf(\"Stack Overflow\\n\");\n    }\n    else\n    {\n        printf(\"Enter The Element To Push : \");\n        scanf(\"%d\", &amp;x);\n\n        top++;\n        stack[top] = x;\n\n        printf(\"%d Pushed To Stack\\n\", x);\n    }\n}\n\nvoid pop()\n{\n    int item, m;\n\n    m = isempty();\n\n    if (m == 1)\n    {\n        printf(\"Stack Underflow\\n\");\n    }\n    else\n    {\n        int item = stack[top];\n        top--;\n\n        printf(\"Popped Element %d\\n\", item);\n    }\n}\n\nvoid display()\n{\n    int i;\n    printf(\"Displaying Stack : \\n\");\n\n    for (int i = top; i &gt;= 0; i--)\n    {\n        printf(\"%d \", stack[i]);\n    }\n    printf(\"\\n\");\n}\n\nint main()\n{\n    int choise, m;\n\n    while (1)\n    {\n        printf(\"\\n*** Stack Menu ***\");\n        printf(\"\\n\\n1. Check If Empty\\n2. Check If Full\\n3. Push\\n4. Pop\\n5. Display\\n6. Exit\");\n        printf(\"\\n\\nEnter Your Choise (1 - 6) : \");\n        scanf(\"%d\", &amp;choise);\n\n        switch (choise)\n        {\n        case 1:\n            m = isempty();\n\n            if (m == 1)\n            {\n                printf(\"\\nStack Is Empty\\n\");\n            }\n            break;\n\n        case 2:\n            m = isfull();\n\n            if (m == 1)\n            {\n                printf(\"\\nStack Is Full\\n\");\n            }\n            else\n            {\n                printf(\"\\nStack Is Not Full\\n\");\n            }\n            break;\n\n        case 3:\n            push();\n            break;\n\n        case 4:\n            pop();\n            break;\n\n        case 5:\n            display();\n            break;\n\n        case 6:\n            exit(0);\n\n        default:\n            printf(\"\\nWrong Choice\");\n        }\n    }\n    return 0;\n}\n</code></pre>"},{"location":"04-08-2025/index.html#output-1","title":"OUTPUT 1","text":"<pre><code>*** Stack Menu ***\n\n1. Check If Empty\n2. Check If Full\n3. Push\n4. Pop\n5. Display\n6. Exit\n\nEnter Your Choise (1 - 6) : 3\nEnter The Element To Push : 4\n4 Pushed To Stack\n\n*** Stack Menu ***\n\n1. Check If Empty\n2. Check If Full\n3. Push\n4. Pop\n5. Display\n6. Exit\n\nEnter Your Choise (1 - 6) : 3\nEnter The Element To Push : 5\n5 Pushed To Stack\n\n*** Stack Menu ***\n\n1. Check If Empty\n2. Check If Full\n3. Push\n4. Pop\n5. Display\n6. Exit\n\nEnter Your Choise (1 - 6) : 3\nEnter The Element To Push : 6\n6 Pushed To Stack\n\n*** Stack Menu ***\n\n1. Check If Empty\n2. Check If Full\n3. Push\n4. Pop\n5. Display\n6. Exit\n\nEnter Your Choise (1 - 6) : 5\nDisplaying Stack : \n6 5 4 \n\n*** Stack Menu ***\n\n1. Check If Empty\n2. Check If Full\n3. Push\n4. Pop\n5. Display\n6. Exit\n\nEnter Your Choise (1 - 6) : 4\nPopped Element 6\n\n*** Stack Menu ***\n\n1. Check If Empty\n2. Check If Full\n3. Push\n4. Pop\n5. Display\n6. Exit\n\nEnter Your Choise (1 - 6) : 6\n</code></pre>"},{"location":"04-08-2025/index.html#exercise-2-local-stack-operations","title":"Exercise 2 : Local Stack Operations","text":"<p>Qestion: Write a program to perform operations of stack.</p> <p>Sollution: View Code</p> <pre><code># include &lt;stdlib.h&gt;  \n# include &lt;stdio.h&gt;  \n\nint isfull(int top, int max)\n{\n    if (top == max - 1)\n    {\n        return 1;\n    }\n    else\n    {\n        return 0;\n    }\n}\n\n\nint isempty(int top)\n{\n    if (top == -1)\n    {\n        return 1;\n    }\n    else\n    {\n        return 0;\n    }\n}\n\nvoid push(int *top, int max, int stack[]) {\n    int x;\n\n    if (isfull(*top, max)) {\n        printf(\"Stack Overflow\\n\");\n\n    } else {\n        printf(\"Enter The Element To Push : \");\n        scanf(\"%d\", &amp;x);\n\n        (*top)++; \n        stack[*top] = x;\n\n        printf(\"%d Pushed To Stack\\n\", x);\n    }\n}\n\nvoid pop(int *top, int stack[]) {\n    int item;\n\n    if (isempty(*top)) {\n        printf(\"Stack Underflow\\n\");\n\n    } else {\n        item = stack[*top];\n        (*top)--; \n\n        printf(\"Popped Element %d\\n\", item);\n    }\n}\n\nvoid display(int top, int stack[])\n{\n    int i;\n    printf(\"Displaying Stack : \\n\");\n\n    if (isempty(top))\n    {\n        printf(\"Stack Is Empty\\n\");\n        return;\n    }\n\n    for (i = top; i &gt;= 0; i--)\n    {\n        printf(\"%d \", stack[i]);\n    }\n    printf(\"\\n\");\n}\n\n\nint main()\n{\n    int choise, m, max;\n\n    printf(\"Enter The Max Size Of Stack : \");\n    scanf(\"%d\", &amp;max);\n\n    int stack[max];\n    int top = -1;\n\n    while (1)\n    {\n        printf(\"\\n*** Stack Menu ***\");\n        printf(\"\\n\\n1. Check If Empty\\n2. Check If Full\\n3. Push\\n4. Pop\\n5. Display\\n6. Exit\");\n        printf(\"\\n\\nEnter Your Choise (1 - 6) : \");\n        scanf(\"%d\", &amp;choise);\n\n        switch (choise)\n        {\n        case 1:\n            m = isempty(top);\n\n            if (m == 1)\n            {\n                printf(\"\\nStack Is Empty\\n\");\n            }\n            else\n            {\n                printf(\"\\nStack Is Not Empty\\n\");\n            }\n            break;\n\n        case 2:\n            m = isfull(top, max);\n\n            if (m == 1)\n            {\n                printf(\"\\nStack Is Full\\n\");\n            }\n            else\n            {\n                printf(\"\\nStack Is Not Full\\n\");\n            }\n            break;\n\n        case 3:\n            push(&amp;top, max, stack);\n            break;\n\n        case 4:\n            pop(&amp;top, stack);\n            break;\n\n        case 5:\n            display(top, stack);\n            break;\n\n        case 6:\n            exit(0);\n\n        default:\n            printf(\"\\nWrong Choice\\n\");\n        }\n    }\n    return 0;\n}\n</code></pre>"},{"location":"04-08-2025/index.html#output-2","title":"OUTPUT 2","text":"<pre><code>Enter The Max Size Of Stack : 3\n\n*** Stack Menu ***\n\n1. Check If Empty\n2. Check If Full\n3. Push\n4. Pop\n5. Display\n6. Exit\n\nEnter Your Choise (1 - 6) : 3\nEnter The Element To Push : 4\n4 Pushed To Stack\n\n*** Stack Menu ***\n\n1. Check If Empty\n2. Check If Full\n3. Push\n4. Pop\n5. Display\n6. Exit\n\nEnter Your Choise (1 - 6) : 3\nEnter The Element To Push : 5\n5 Pushed To Stack\n\n*** Stack Menu ***\n\n1. Check If Empty\n2. Check If Full\n3. Push\n4. Pop\n5. Display\n6. Exit\n\nEnter Your Choise (1 - 6) : 3\nEnter The Element To Push : 6\n6 Pushed To Stack\n\n*** Stack Menu ***\n\n1. Check If Empty\n2. Check If Full\n3. Push\n4. Pop\n5. Display\n6. Exit\n\nEnter Your Choise (1 - 6) : 5\nDisplaying Stack : \n6 5 4 \n\n*** Stack Menu ***\n\n1. Check If Empty\n2. Check If Full\n3. Push\n4. Pop\n5. Display\n6. Exit\n\nEnter Your Choise (1 - 6) : 4\nPopped Element 6\n\n*** Stack Menu ***\n\n1. Check If Empty\n2. Check If Full\n3. Push\n4. Pop\n5. Display\n6. Exit\n\nEnter Your Choise (1 - 6) : 6\n</code></pre>"},{"location":"04-08-2025/GlobalStack.html","title":"GlobalStack.cpp","text":"<pre><code>#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n#define MAX 3\n\nint stack[MAX];\nint top = -1;\n\nint isfull()\n{\n    if (top == MAX - 1)\n    {\n        return 1;\n    }\n    else\n    {\n        return 0;\n    }\n}\n\nint isempty()\n{\n    if (top == -1)\n    {\n        return 1;\n    }\n    else\n    {\n        return 0;\n    }\n}\n\nvoid push()\n{\n    int x, m;\n    m = isfull();\n\n    if (m == 1)\n    {\n        printf(\"Stack Overflow\\n\");\n    }\n    else\n    {\n        printf(\"Enter The Element To Push : \");\n        scanf(\"%d\", &amp;x);\n\n        top++;\n        stack[top] = x;\n\n        printf(\"%d Pushed To Stack\\n\", x);\n    }\n}\n\nvoid pop()\n{\n    int item, m;\n\n    m = isempty();\n\n    if (m == 1)\n    {\n        printf(\"Stack Underflow\\n\");\n    }\n    else\n    {\n        int item = stack[top];\n        top--;\n\n        printf(\"Popped Element %d\\n\", item);\n    }\n}\n\nvoid display()\n{\n    int i;\n    printf(\"Displaying Stack : \\n\");\n\n    for (int i = top; i &gt;= 0; i--)\n    {\n        printf(\"%d \", stack[i]);\n    }\n    printf(\"\\n\");\n}\n\nint main()\n{\n    int choise, m;\n\n    while (1)\n    {\n        printf(\"\\n*** Stack Menu ***\");\n        printf(\"\\n\\n1. Check If Empty\\n2. Check If Full\\n3. Push\\n4. Pop\\n5. Display\\n6. Exit\");\n        printf(\"\\n\\nEnter Your Choise (1 - 6) : \");\n        scanf(\"%d\", &amp;choise);\n\n        switch (choise)\n        {\n        case 1:\n            m = isempty();\n\n            if (m == 1)\n            {\n                printf(\"\\nStack Is Empty\\n\");\n            }\n            break;\n\n        case 2:\n            m = isfull();\n\n            if (m == 1)\n            {\n                printf(\"\\nStack Is Full\\n\");\n            }\n            else\n            {\n                printf(\"\\nStack Is Not Full\\n\");\n            }\n            break;\n\n        case 3:\n            push();\n            break;\n\n        case 4:\n            pop();\n            break;\n\n        case 5:\n            display();\n            break;\n\n        case 6:\n            exit(0);\n\n        default:\n            printf(\"\\nWrong Choice\");\n        }\n    }\n    return 0;\n}\n</code></pre>"},{"location":"04-08-2025/LocalStack.html","title":"LocalStack.cpp","text":"<pre><code># include &lt;stdlib.h&gt;  \n# include &lt;stdio.h&gt;  \n\nint isfull(int top, int max)\n{\n    if (top == max - 1)\n    {\n        return 1;\n    }\n    else\n    {\n        return 0;\n    }\n}\n\n\nint isempty(int top)\n{\n    if (top == -1)\n    {\n        return 1;\n    }\n    else\n    {\n        return 0;\n    }\n}\n\nvoid push(int *top, int max, int stack[]) {\n    int x;\n\n    if (isfull(*top, max)) {\n        printf(\"Stack Overflow\\n\");\n\n    } else {\n        printf(\"Enter The Element To Push : \");\n        scanf(\"%d\", &amp;x);\n\n        (*top)++; \n        stack[*top] = x;\n\n        printf(\"%d Pushed To Stack\\n\", x);\n    }\n}\n\nvoid pop(int *top, int stack[]) {\n    int item;\n\n    if (isempty(*top)) {\n        printf(\"Stack Underflow\\n\");\n\n    } else {\n        item = stack[*top];\n        (*top)--; \n\n        printf(\"Popped Element %d\\n\", item);\n    }\n}\n\nvoid display(int top, int stack[])\n{\n    int i;\n    printf(\"Displaying Stack : \\n\");\n\n    if (isempty(top))\n    {\n        printf(\"Stack Is Empty\\n\");\n        return;\n    }\n\n    for (i = top; i &gt;= 0; i--)\n    {\n        printf(\"%d \", stack[i]);\n    }\n    printf(\"\\n\");\n}\n\n\nint main()\n{\n    int choise, m, max;\n\n    printf(\"Enter The Max Size Of Stack : \");\n    scanf(\"%d\", &amp;max);\n\n    int stack[max];\n    int top = -1;\n\n    while (1)\n    {\n        printf(\"\\n*** Stack Menu ***\");\n        printf(\"\\n\\n1. Check If Empty\\n2. Check If Full\\n3. Push\\n4. Pop\\n5. Display\\n6. Exit\");\n        printf(\"\\n\\nEnter Your Choise (1 - 6) : \");\n        scanf(\"%d\", &amp;choise);\n\n        switch (choise)\n        {\n        case 1:\n            m = isempty(top);\n\n            if (m == 1)\n            {\n                printf(\"\\nStack Is Empty\\n\");\n            }\n            else\n            {\n                printf(\"\\nStack Is Not Empty\\n\");\n            }\n            break;\n\n        case 2:\n            m = isfull(top, max);\n\n            if (m == 1)\n            {\n                printf(\"\\nStack Is Full\\n\");\n            }\n            else\n            {\n                printf(\"\\nStack Is Not Full\\n\");\n            }\n            break;\n\n        case 3:\n            push(&amp;top, max, stack);\n            break;\n\n        case 4:\n            pop(&amp;top, stack);\n            break;\n\n        case 5:\n            display(top, stack);\n            break;\n\n        case 6:\n            exit(0);\n\n        default:\n            printf(\"\\nWrong Choice\\n\");\n        }\n    }\n    return 0;\n}\n</code></pre>"},{"location":"11-08-2025/index.html","title":"Programming Exercises - August 11, 2025","text":""},{"location":"11-08-2025/index.html#exercise-1-string-operations","title":"Exercise 1 : String Operations","text":"<p>Qestion: Write a single program in c with menu facility to perform the following string operations :</p> <pre><code>            1. String Length\n\n            2. String Reverse\n\n            3. String Concatenation\n\n            4. String Compare\n\n            5. Search A Character Within A String\n</code></pre> <p>Sollution: View Code</p> <pre><code>#include &lt;stdio.h&gt;\n\n// Loop With Counter\nint stringLength(char *str)\n{\n    int len = 0;\n    while (str[len] != '\\0')\n    {\n        len++;\n    }\n    return len;\n}\n\n// Loop And Swap The Values Using Temp\nvoid stringReverse(char *str)\n{\n    int len = stringLength(str);\n    int i, j;\n    char temp;\n\n    for (i = 0, j = len - 1; i &lt; j; i++, j--)\n    {\n        temp = str[i];\n        str[i] = str[j];\n        str[j] = temp;\n    }\n}\n\n// Run Two Loops And Check\nvoid stringConcatenate(char *dest, char *src)\n{\n    int i = 0, j = 0;\n\n    while (dest[i] != '\\0')\n    {\n        i++;\n    }\n\n    while (src[j] != '\\0')\n    {\n        dest[i] = src[j];\n        i++;\n        j++;\n    }\n\n    dest[i] = '\\0';\n}\n\n// Search Each With A loop\nint stringCompare(char *str1, char *str2)\n{\n    int i = 0;\n\n    while (str1[i] != '\\0' &amp;&amp; str2[i] != '\\0')\n    {\n        if (str1[i] != str2[i])\n        {\n            return 0;\n        }\n        i++;\n    }\n\n    return (str1[i] == '\\0' &amp;&amp; str2[i] == '\\0');\n}\n\n// Linear Search Loop\nint searchCharacter(char *str, char ch)\n{\n    int i = 0;\n\n    while (str[i] != '\\0')\n    {\n        if (str[i] == ch)\n        {\n            return i;\n        }\n        i++;\n    }\n    return -1;\n}\n\nint main()\n{\n    int choice;\n    char str1[100], str2[100];\n    char ch;\n    int index;\n\n    do\n    {\n        printf(\"\\n\\n*** String Operations Menu ***\\n\");\n        printf(\"1. String Length\\n\");\n        printf(\"2. String Reverse\\n\");\n        printf(\"3. String Concatenation\\n\");\n        printf(\"4. String Compare\\n\");\n        printf(\"5. Character Search\\n\");\n        printf(\"6. Exit\\n\");\n        printf(\"Enter Your Choice (1 - 6): \");\n        scanf(\"%d\", &amp;choice);\n\n        switch (choice)\n        {\n        case 1:\n            printf(\"Enter A String : \");\n            scanf(\"%s\", str1);\n\n            printf(\"The Length Of String : %d\\n\", stringLength(str1));\n            break;\n\n        case 2:\n            printf(\"Enter String To Reverse : \");\n            scanf(\"%s\", str1);\n\n            stringReverse(str1);\n\n            printf(\"Reversed String : %s\\n\", str1);\n            break;\n\n        case 3:\n            printf(\"Enter First String : \");\n            scanf(\"%s\", str1);\n\n            printf(\"Enter Second String : \");\n            scanf(\"%s\", str2);\n\n            stringConcatenate(str1, str2);\n\n            printf(\"Concatenated String : %s\\n\", str1);\n            break;\n\n        case 4:\n            printf(\"Enter First String : \");\n            scanf(\"%s\", str1);\n\n            printf(\"Enter Second String : \");\n            scanf(\"%s\", str2);\n\n            if (stringCompare(str1, str2))\n            {\n                printf(\"The Stings Not Equal.\\n\");\n            }\n            else\n            {\n                printf(\"The Strings Are Not Euqal\\n\");\n            }\n            break;\n\n        case 5:\n            printf(\"Enter A String : \");\n            scanf(\"%s\", str1);\n\n            printf(\"Enter A Character To Search : \");\n            scanf(\" %c\", &amp;ch);\n\n            index = searchCharacter(str1, ch);\n\n            if (index != -1)\n            {\n                printf(\"Character '%c' Found At %d\\n\", ch, index);\n            }\n            else\n            {\n                printf(\"Character '%c' Not Found\\n\", ch);\n            }\n            break;\n\n        case 6:\n            printf(\"Exiting Program\\n\");\n            break;\n\n        default:\n            printf(\"Invalid Choise\\n\");\n        }\n\n    } while (choice != 6);\n\n    return 0;\n}\n</code></pre>"},{"location":"11-08-2025/index.html#output-1","title":"OUTPUT 1","text":"<pre><code>*** String Operations Menu ***\n1. String Length\n2. String Reverse\n3. String Concatenation\n4. String Compare\n5. Character Search\n6. Exit\nEnter Your Choice (1 - 6): 1\nEnter A String : SOHAM\nThe Length Of String : 5\n\n\n*** String Operations Menu ***\n1. String Length\n2. String Reverse\n3. String Concatenation\n4. String Compare\n5. Character Search\n6. Exit\nEnter Your Choice (1 - 6): 2\nEnter String To Reverse : SOHAM\nReversed String : MAHOS\n\n\n*** String Operations Menu ***\n1. String Length\n2. String Reverse\n3. String Concatenation\n4. String Compare\n5. Character Search\n6. Exit\nEnter Your Choice (1 - 6): 3\nEnter First String : SO\nEnter Second String : HAM\nConcatenated String : SOHAM\n\n\n*** String Operations Menu ***\n1. String Length\n2. String Reverse\n3. String Concatenation\n4. String Compare\n5. Character Search\n6. Exit\nEnter Your Choice (1 - 6): 4\nEnter First String : SOHAM\nEnter Second String : Soham\nThe Strings Are Not Euqal\n\n\n*** String Operations Menu ***\n1. String Length\n2. String Reverse\n3. String Concatenation\n4. String Compare\n5. Character Search\n6. Exit\nEnter Your Choice (1 - 6): 5\nEnter A String : SOHAM\nEnter A Character To Search : H\nCharacter 'H' Found At 2\n\n\n*** String Operations Menu ***\n1. String Length\n2. String Reverse\n3. String Concatenation\n4. String Compare\n5. Character Search\n6. Exit\nEnter Your Choice (1 - 6): 6\nExiting Program\n</code></pre>"},{"location":"11-08-2025/StringOperations.html","title":"StringOperations.cpp","text":"<pre><code>#include &lt;stdio.h&gt;\n\n// Loop With Counter\nint stringLength(char *str)\n{\n    int len = 0;\n    while (str[len] != '\\0')\n    {\n        len++;\n    }\n    return len;\n}\n\n// Loop And Swap The Values Using Temp\nvoid stringReverse(char *str)\n{\n    int len = stringLength(str);\n    int i, j;\n    char temp;\n\n    for (i = 0, j = len - 1; i &lt; j; i++, j--)\n    {\n        temp = str[i];\n        str[i] = str[j];\n        str[j] = temp;\n    }\n}\n\n// Run Two Loops And Check\nvoid stringConcatenate(char *dest, char *src)\n{\n    int i = 0, j = 0;\n\n    while (dest[i] != '\\0')\n    {\n        i++;\n    }\n\n    while (src[j] != '\\0')\n    {\n        dest[i] = src[j];\n        i++;\n        j++;\n    }\n\n    dest[i] = '\\0';\n}\n\n// Search Each With A loop\nint stringCompare(char *str1, char *str2)\n{\n    int i = 0;\n\n    while (str1[i] != '\\0' &amp;&amp; str2[i] != '\\0')\n    {\n        if (str1[i] != str2[i])\n        {\n            return 0;\n        }\n        i++;\n    }\n\n    return (str1[i] == '\\0' &amp;&amp; str2[i] == '\\0');\n}\n\n// Linear Search Loop\nint searchCharacter(char *str, char ch)\n{\n    int i = 0;\n\n    while (str[i] != '\\0')\n    {\n        if (str[i] == ch)\n        {\n            return i;\n        }\n        i++;\n    }\n    return -1;\n}\n\nint main()\n{\n    int choice;\n    char str1[100], str2[100];\n    char ch;\n    int index;\n\n    do\n    {\n        printf(\"\\n\\n*** String Operations Menu ***\\n\");\n        printf(\"1. String Length\\n\");\n        printf(\"2. String Reverse\\n\");\n        printf(\"3. String Concatenation\\n\");\n        printf(\"4. String Compare\\n\");\n        printf(\"5. Character Search\\n\");\n        printf(\"6. Exit\\n\");\n        printf(\"Enter Your Choice (1 - 6): \");\n        scanf(\"%d\", &amp;choice);\n\n        switch (choice)\n        {\n        case 1:\n            printf(\"Enter A String : \");\n            scanf(\"%s\", str1);\n\n            printf(\"The Length Of String : %d\\n\", stringLength(str1));\n            break;\n\n        case 2:\n            printf(\"Enter String To Reverse : \");\n            scanf(\"%s\", str1);\n\n            stringReverse(str1);\n\n            printf(\"Reversed String : %s\\n\", str1);\n            break;\n\n        case 3:\n            printf(\"Enter First String : \");\n            scanf(\"%s\", str1);\n\n            printf(\"Enter Second String : \");\n            scanf(\"%s\", str2);\n\n            stringConcatenate(str1, str2);\n\n            printf(\"Concatenated String : %s\\n\", str1);\n            break;\n\n        case 4:\n            printf(\"Enter First String : \");\n            scanf(\"%s\", str1);\n\n            printf(\"Enter Second String : \");\n            scanf(\"%s\", str2);\n\n            if (stringCompare(str1, str2))\n            {\n                printf(\"The Stings Are Equal.\\n\");\n            }\n            else\n            {\n                printf(\"The Strings Are Not Euqal\\n\");\n            }\n            break;\n\n        case 5:\n            printf(\"Enter A String : \");\n            scanf(\"%s\", str1);\n\n            printf(\"Enter A Character To Search : \");\n            scanf(\" %c\", &amp;ch);\n\n            index = searchCharacter(str1, ch);\n\n            if (index != -1)\n            {\n                printf(\"Character '%c' Found At %d\\n\", ch, index);\n            }\n            else\n            {\n                printf(\"Character '%c' Not Found\\n\", ch);\n            }\n            break;\n\n        case 6:\n            printf(\"Exiting Program\\n\");\n            break;\n\n        default:\n            printf(\"Invalid Choise\\n\");\n        }\n\n    } while (choice != 6);\n\n    return 0;\n}\n</code></pre>"},{"location":"18-08-2025/index.html","title":"Programming Exercises - August 18, 2025","text":""},{"location":"18-08-2025/index.html#exercise-1-linked-list-operations","title":"Exercise 1 : Linked List Operations","text":"<p>Qestion: Write a menu driven program to implement single linklist and write the following functions :</p> <pre><code>            1. Append()\n\n            2. Display ()\n</code></pre> <p>Note -  i. Data parts contain Roll,Name,Marks         ii. Display those student names with marks &gt;= 50</p> <p>Sollution: View Code</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nstruct Node\n{\n    char name[20];\n    int roll, marks;\n    struct Node *next;\n};\n\nstruct Node *Head = NULL, *Last = NULL;\n\nvoid appendNode()\n{\n    struct Node *newNode = (struct Node *)malloc(sizeof(struct Node));\n\n    printf(\"\\nEnter Student Data ~\");\n    printf(\"\\nEnter Student Name : \");\n    scanf(\"%s\", &amp;newNode-&gt;name);\n\n    printf(\"\\nEnter Student Roll No : \");\n    scanf(\"%d\", &amp;newNode-&gt;roll);\n\n    printf(\"\\nEnter Student Marks : \");\n    scanf(\"%d\", &amp;newNode-&gt;marks);\n\n    newNode-&gt;next = NULL;\n\n    if (Head == NULL)\n    {\n        Head = newNode;\n        Last = newNode;\n    }\n    else\n    {\n        Last-&gt;next = newNode;\n        Last = newNode;\n    }\n}\n\nvoid displayNode()\n{\n    struct Node *newNode = Head;\n\n    if (Head == NULL)\n    {\n        printf(\"List Empty!\");\n    }\n    else\n    {\n        while (newNode != NULL)\n        {\n            if (newNode-&gt;marks &gt;= 50)\n            {\n                printf(\"%s\\n\", newNode-&gt;name);\n            }\n            newNode = newNode-&gt;next;\n        }\n    }\n}\n\nint main()\n{\n    int choise;\n\n    while (1)\n    {\n        printf(\"*** Linked List Operations ***\\n\");\n        printf(\"\\n1. Append New Student\\n2. Display Students\\n3. Exit\");\n\n        printf(\"\\nEnter Your Choise : \");\n        scanf(\"%d\", &amp;choise);\n\n        switch (choise)\n        {\n        case 1:\n            appendNode();\n            break;\n\n        case 2:\n            displayNode();\n            break;\n\n        case 3:\n            exit(0);\n\n        default:\n            printf(\"Invalid Input\");\n            break;\n        }\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"18-08-2025/index.html#output-1","title":"OUTPUT 1","text":"<pre><code>*** Linked List Operations ***\n\n1. Append New Student\n2. Display Students\n3. Exit\nEnter Your Choise : 1\n\nEnter Student Data ~\nEnter Student Name : S1             \n\nEnter Student Roll No : 1\n\nEnter Student Marks : 30\n*** Linked List Operations ***\n\n1. Append New Student\n2. Display Students\n3. Exit\nEnter Your Choise : 1\n\nEnter Student Data ~\nEnter Student Name : S2\n\nEnter Student Roll No : 2 \n\nEnter Student Marks : 90\n*** Linked List Operations ***\n\n1. Append New Student\n2. Display Students\n3. Exit\nEnter Your Choise : 2\nS2\n*** Linked List Operations ***\n\n1. Append New Student\n2. Display Students\n3. Exit\nEnter Your Choise : 3\n</code></pre>"},{"location":"18-08-2025/StudentLinkedList.html","title":"StudentLinkedList.cpp","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nstruct Node\n{\n    char name[20];\n    int roll, marks;\n    struct Node *next;\n};\n\nstruct Node *Head = NULL, *Last = NULL;\n\nvoid appendNode()\n{\n    struct Node *newNode = (struct Node *)malloc(sizeof(struct Node));\n\n    printf(\"\\nEnter Student Data ~\");\n    printf(\"\\nEnter Student Name : \");\n    scanf(\"%s\", &amp;newNode-&gt;name);\n\n    printf(\"\\nEnter Student Roll No : \");\n    scanf(\"%d\", &amp;newNode-&gt;roll);\n\n    printf(\"\\nEnter Student Marks : \");\n    scanf(\"%d\", &amp;newNode-&gt;marks);\n\n    newNode-&gt;next = NULL;\n\n    if (Head == NULL)\n    {\n        Head = newNode;\n        Last = newNode;\n    }\n    else\n    {\n        Last-&gt;next = newNode;\n        Last = newNode;\n    }\n}\n\nvoid displayNode()\n{\n    struct Node *newNode = Head;\n\n    if (Head == NULL)\n    {\n        printf(\"List Empty!\");\n    }\n    else\n    {\n        while (newNode != NULL)\n        {\n            if (newNode-&gt;marks &gt;= 50)\n            {\n                printf(\"%s\\n\", newNode-&gt;name);\n            }\n            newNode = newNode-&gt;next;\n        }\n    }\n}\n\nint main()\n{\n    int choise;\n\n    while (1)\n    {\n        printf(\"*** Linked List Operations ***\\n\");\n        printf(\"\\n1. Append New Student\\n2. Display Students\\n3. Exit\");\n\n        printf(\"\\nEnter Your Choise : \");\n        scanf(\"%d\", &amp;choise);\n\n        switch (choise)\n        {\n        case 1:\n            appendNode();\n            break;\n\n        case 2:\n            displayNode();\n            break;\n\n        case 3:\n            exit(0);\n\n        default:\n            printf(\"Invalid Input\");\n            break;\n        }\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"24-07-2025/index.html","title":"Programming Exercises - July 24, 2025","text":""},{"location":"24-07-2025/index.html#exercise-1-staic-liner-search","title":"Exercise 1 : Staic Liner Search","text":"<p>Qestion: Write a program to perform liner search using static memory allocation.</p> <p>Sollution: View Code</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint linerSearch(int arr[100], int n, int key)\n{\n    for (int i = 0; i &lt; n; i++)\n    {\n        if (arr[i] == key)\n        {\n            return i;\n        }\n    }\n\n    return -1;\n}\n\nint main()\n{\n    int n, key, arr[100];\n\n    printf(\"Enter The Number Of Elements : \");\n    scanf(\"%d\", &amp;n);\n\n    for (int i = 0; i &lt; n; i++)\n    {\n        printf(\"Enter The Element %d : \", i + 1);\n        scanf(\"%d\", &amp;arr[i]);\n    }\n\n    printf(\"Enter The Key To Be Searched : \");\n    scanf(\"%d\", &amp;key);\n\n    int index = linerSearch(arr, n, key);\n\n    if (index != 1)\n    {\n        printf(\"Element Found At Index : %d\\n\", index);\n    }\n    else\n    {\n        printf(\"Element Not Found\\n\");\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"24-07-2025/index.html#output-1","title":"OUTPUT 1","text":"<pre><code>Enter The Number Of Elements : 3\nEnter The Element 1 : 2\nEnter The Element 2 : 6\nEnter The Element 3 : 9\nEnter The Key To Be Searched : 9\nElement Found At Index : 2\n</code></pre>"},{"location":"24-07-2025/index.html#exercise-2-dynamic-linear-search","title":"Exercise 2 : Dynamic Linear Search","text":"<p>Qestion: Write a program to perform liner search using dynamic memory allocation.</p> <p>Sollution 1: View Code Sollution 2: View Code</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint linerSearch(int *arr, int n, int key)\n{\n    for (int i = 0; i &lt; n; i++)\n    {\n        if (arr[i] == key)\n        {\n            return i;\n        }\n    }\n\n    return -1;\n}\n\nint main()\n{\n    int n, key, *arr;\n\n    printf(\"Enter The Number Of Elements : \");\n    scanf(\"%d\", &amp;n);\n\n    arr = (int *)malloc(n * sizeof(int));\n\n    for (int i = 0; i &lt; n; i++)\n    {\n        printf(\"Enter The Element %d : \", i + 1);\n        scanf(\"%d\", &amp;arr[i]);\n    }\n\n    printf(\"Enter The Key To Be Searched : \");\n    scanf(\"%d\", &amp;key);\n\n    int index = linerSearch(arr, n, key);\n\n    if (index != -1)\n    {\n        printf(\"Element Found At Index : %d\\n\", index);\n    }\n    else\n    {\n        printf(\"Element Not Found\\n\");\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"24-07-2025/index.html#output-2","title":"OUTPUT 2","text":"<pre><code>Enter The Number Of Elements : 3\nEnter The Element 1 : 4\nEnter The Element 2 : 5\nEnter The Element 3 : 6\nEnter The Key To Be Searched : 5\nElement Found At Index : 1\n</code></pre>"},{"location":"24-07-2025/DynamicLinearSearch.html","title":"DynamicLinearSearch.cpp","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint linerSearch(int *arr, int n, int key)\n{\n    for (int i = 0; i &lt; n; i++)\n    {\n        if (arr[i] == key)\n        {\n            return i;\n        }\n    }\n\n    return -1;\n}\n\nint main()\n{\n    int n, key, *arr;\n\n    printf(\"Enter The Number Of Elements : \");\n    scanf(\"%d\", &amp;n);\n\n    arr = (int *)malloc(n * sizeof(int));\n\n    for (int i = 0; i &lt; n; i++)\n    {\n        printf(\"Enter The Element %d : \", i + 1);\n        scanf(\"%d\", &amp;arr[i]);\n    }\n\n    printf(\"Enter The Key To Be Searched : \");\n    scanf(\"%d\", &amp;key);\n\n    int index = linerSearch(arr, n, key);\n\n    if (index != -1)\n    {\n        printf(\"Element Found At Index : %d\\n\", index);\n    }\n    else\n    {\n        printf(\"Element Not Found\\n\");\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"24-07-2025/DynamicLinearSearchPointer.html","title":"DynamicLinearSearchPointer.cpp","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint linerSearch(int *arr, int n, int key)\n{\n    for (int i = 0; i &lt; n; i++)\n    {\n        if (*(arr + i) == key)\n        {\n            return i;\n        }\n    }\n\n    return -1;\n}\n\nint main()\n{\n    int n, key, *arr;\n\n    printf(\"Enter The Number Of Elements : \");\n    scanf(\"%d\", &amp;n);\n\n    arr = (int *)malloc(n * sizeof(int));\n\n    for (int i = 0; i &lt; n; i++)\n    {\n        printf(\"Enter The Element %d : \", i + 1);\n        scanf(\"%d\", arr + i);\n    }\n\n    printf(\"Enter The Key To Be Searched : \");\n    scanf(\"%d\", &amp;key);\n\n    int index = linerSearch(arr, n, key);\n\n    if (index != -1)\n    {\n        printf(\"Element Found At Index : %d\\n\", index);\n    }\n    else\n    {\n        printf(\"Element Not Found\\n\");\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"24-07-2025/StaticLinearSearch.html","title":"StaticLinearSearch.cpp","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint linerSearch(int arr[100], int n, int key)\n{\n    for (int i = 0; i &lt; n; i++)\n    {\n        if (arr[i] == key)\n        {\n            return i;\n        }\n    }\n\n    return -1;\n}\n\nint main()\n{\n    int n, key, arr[100];\n\n    printf(\"Enter The Number Of Elements : \");\n    scanf(\"%d\", &amp;n);\n\n    for (int i = 0; i &lt; n; i++)\n    {\n        printf(\"Enter The Element %d : \", i + 1);\n        scanf(\"%d\", &amp;arr[i]);\n    }\n\n    printf(\"Enter The Key To Be Searched : \");\n    scanf(\"%d\", &amp;key);\n\n    int index = linerSearch(arr, n, key);\n\n    if (index != -1)\n    {\n        printf(\"Element Found At Index : %d\\n\", index);\n    }\n    else\n    {\n        printf(\"Element Not Found\\n\");\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"Notes/AsymptoticNotation.html","title":"Asymptotic Notations","text":""},{"location":"Notes/AsymptoticNotation.html#what-is-asymptotic-notation","title":"What is Asymptotic Notation?","text":"<p>Imagine you\u2019re trying to see how fast an algorithm is as your input size grows. You don\u2019t care about small details like:</p> <ul> <li>The brand of your CPU</li> <li>Whether you used <code>i++</code> or <code>i += 1</code></li> <li>Exact number of milliseconds</li> </ul> <p>Instead, you want to know: \ud83d\udca1 \u201cWhat happens when my input gets HUGE?\u201d</p> <p>That\u2019s where asymptotic notation comes in. It\u2019s like short-hand math for describing growth rates of algorithms.</p>"},{"location":"Notes/AsymptoticNotation.html#why-do-we-need-it","title":"Why do we need it?","text":"<ol> <li>Ignore constants and small terms \u2014 focus on the big picture.</li> <li>Compare algorithms fairly \u2014 across different machines.</li> <li>Predict scalability \u2014 how well will it handle massive input.</li> </ol> <p>Example:</p> <ul> <li>Algorithm A takes <code>0.05n\u00b2 + 2n + 3</code> operations.</li> <li>Algorithm B takes <code>100n + 10</code> operations.</li> </ul> <p>For small <code>n</code>, B might be slower due to the big constant <code>100</code>. But as <code>n</code> grows, <code>n\u00b2</code> will crush <code>n</code>, so A will eventually be much slower.</p>"},{"location":"Notes/AsymptoticNotation.html#the-main-asymptotic-notations","title":"The Main Asymptotic Notations","text":"<p>There are five primary notations you\u2019ll see often.</p>"},{"location":"Notes/AsymptoticNotation.html#big-o-upper-bound","title":"Big O \u2014 Upper Bound","text":"<p>Definition: Describes the worst-case growth rate. It tells you: \u201cIt won\u2019t grow faster than this.\u201d</p> <p>Formal idea:</p> <pre><code>f(n) = O(g(n))  means  f(n) \u2264 C \u00d7 g(n)   for some constant C, for large enough n.\n</code></pre> <p>Example: If an algorithm takes <code>3n + 2</code> steps, then it\u2019s O(n). It won\u2019t ever grow faster than some multiple of <code>n</code>.</p> <p>You use Big O for:</p> <ul> <li>Worst-case runtime (common in competitive programming).</li> <li>Space complexity upper bound.</li> </ul>"},{"location":"Notes/AsymptoticNotation.html#big-omega-lower-bound","title":"Big Omega (\u03a9) \u2014 Lower Bound","text":"<p>Definition: Describes the best-case growth rate. It says: \u201cIt will take at least this much time.\u201d</p> <p>Formal idea:</p> <pre><code>f(n) = \u03a9(g(n))  means  f(n) \u2265 C \u00d7 g(n)   for some constant C, for large enough n.\n</code></pre> <p>Example: If you must check every element at least once, best case is \u03a9(n).</p>"},{"location":"Notes/AsymptoticNotation.html#big-theta-tight-bound","title":"Big Theta (\u0398) \u2014 Tight Bound","text":"<p>Definition: Describes an exact growth rate. It says: \u201cIt grows at this rate, no faster, no slower (asymptotically).\u201d</p> <p>Formal idea:</p> <pre><code>f(n) = \u0398(g(n))  means  it\u2019s both O(g(n)) and \u03a9(g(n)).\n</code></pre> <p>Example: <code>5n + 3</code> is \u0398(n) because:</p> <ul> <li>Upper bound is O(n)</li> <li>Lower bound is \u03a9(n)</li> </ul> <p>Think: \u0398 is like pinning it down exactly.</p>"},{"location":"Notes/AsymptoticNotation.html#little-o-strictly-less-than","title":"Little o \u2014 Strictly Less Than","text":"<p>Definition: Describes that a function grows strictly slower than another.</p> <p>Formal idea:</p> <pre><code>f(n) = o(g(n))  means  f(n) grows slower than g(n), and ratio \u2192 0 as n \u2192 \u221e.\n</code></pre> <p>Example: <code>n</code> is <code>o(n\u00b2)</code> because as n grows, <code>n / n\u00b2 = 1/n \u2192 0</code>.</p>"},{"location":"Notes/AsymptoticNotation.html#little-omega-strictly-greater-than","title":"Little omega \u2014 Strictly Greater Than","text":"<p>Definition: Opposite of little o. Function grows strictly faster.</p> <p>Formal idea:</p> <pre><code>f(n) = \u03c9(g(n))  means  f(n) grows faster than g(n), and ratio \u2192 \u221e as n \u2192 \u221e.\n</code></pre> <p>Example: <code>n\u00b2</code> is <code>\u03c9(n)</code> because <code>n\u00b2 / n = n \u2192 \u221e</code>.</p> <p></p>"},{"location":"Notes/AsymptoticNotation.html#order-of-growth-cheat-sheet","title":"Order of Growth Cheat Sheet","text":"<p>From slowest to fastest (common ones):</p> Growth Rate Name Example O(1) Constant time Access array element O(log n) Logarithmic Binary search O(n) Linear Loop through array O(n log n) Log-linear Merge sort O(n\u00b2) Quadratic Nested loops O(n\u00b3) Cubic Triple nested loops O(2\u207f) Exponential Naive recursive Fibonacci O(n!) Factorial Traveling salesman brute-force"},{"location":"Notes/AsymptoticNotation.html#dropping-constants-lower-order-terms","title":"Dropping Constants &amp; Lower-Order Terms","text":"<p>When writing Big O, we only care about the dominant term as <code>n \u2192 \u221e</code>.</p> <p>Example: <code>T(n) = 3n\u00b2 + 10n + 5</code> \u2192 O(n\u00b2) Because:</p> <ul> <li><code>n\u00b2</code> dominates for large <code>n</code></li> <li>Constants (3, 10, 5) don\u2019t matter.</li> </ul>"},{"location":"Notes/AsymptoticNotation.html#best-worst-and-average-cases","title":"Best, Worst, and Average Cases","text":"<ul> <li>Best case \u2192 Often given in \u03a9 notation.</li> <li>Worst case \u2192 Often given in O notation.</li> <li>Average case \u2192 Can also use \u0398 notation.</li> </ul> <p>Example: Linear search in an array of size <code>n</code>:</p> <ul> <li>Best case (element at start) \u2192 \u03a9(1)</li> <li>Worst case (element at end or absent) \u2192 O(n)</li> <li>Average case \u2192 \u0398(n)</li> </ul>"},{"location":"Notes/AsymptoticNotation.html#graphical-intuition","title":"Graphical Intuition","text":"<p>If we plotted time vs input size:</p> <ul> <li>O(n) \u2192 straight upward slope</li> <li>O(log n) \u2192 rises quickly at first, then flattens</li> <li>O(n\u00b2) \u2192 curve gets steep fast</li> <li>O(2\u207f) \u2192 skyrockets almost immediately</li> </ul>"},{"location":"Notes/AsymptoticNotation.html#quick-summary-table","title":"Quick Summary Table","text":"Notation Meaning Says What? Example O(g(n)) Upper bound Worst-case O(n\u00b2) \u03a9(g(n)) Lower bound Best-case \u03a9(n) \u0398(g(n)) Tight bound Exact asymptotic behavior \u0398(n) o(g(n)) Strictly less Grows slower o(n\u00b2) \u03c9(g(n)) Strictly more Grows faster \u03c9(n)"},{"location":"Notes/BubbleSort.html","title":"Bubble Sort","text":"<p>Bubble Sort is the simplest sorting algorithm that works by repeatedly swapping the adjacent elements if they are in the wrong order. This algorithm is not suitable for large data sets as its average and worst-case time complexity are quite high.</p> <p>We sort the array using multiple passes. After the first pass, the maximum element goes to end (its correct position). Same way, after second pass, the second largest element goes to second last position and so on.</p> <p>In every pass, we process only those elements that have already not moved to correct position. After k passes, the largest k elements must have been moved to the last k positions.</p> <p>In a pass, we consider remaining elements and compare all adjacent and swap if larger element is before a smaller element. If we keep doing this, we get the largest (among the remaining elements) at its correct position.</p>"},{"location":"Notes/BubbleSort.html#visualization","title":"Visualization","text":""},{"location":"Notes/BubbleSort.html#time-complexity","title":"Time Complexity","text":"Case Time Complexity Best Case O(n) Average Case O(n^2) Worst Case O(n^2) <p>Where n is the number of elements in the array.</p>"},{"location":"Notes/BubbleSort.html#space-complexity","title":"Space Complexity","text":"Case Space Complexity All Cases O(1)"},{"location":"Notes/LinearSearch.html","title":"Linear Search","text":"<p>In Linear Search, we iterate over all the elements of the array and check if it the current element is equal to the target element. If we find any element to be equal to the target element, then return the index of the current element. Otherwise, if no element is equal to the target element, then return -1 as the element is not found. Linear search is also known as sequential search.</p>"},{"location":"Notes/LinearSearch.html#visualization","title":"Visualization","text":""},{"location":"Notes/LinearSearch.html#time-complexity","title":"Time Complexity","text":"Case Time Complexity Best Case O(1) Average Case O(n) Worst Case O(n) <p>Where n is the number of elements in the array.</p>"},{"location":"Notes/LinearSearch.html#space-complexity","title":"Space Complexity","text":"Case Space Complexity All Cases O(1) <p>Linear search uses a constant amount of extra space regardless of the input size.</p>"},{"location":"Notes/Stack.html","title":"Stack","text":"<p>Stack is the linear data structure that follows the Last in, First Out(LIFO) principle of data insertion and deletion. It means that the element that is inserted last will be the first one to be removed and the element that is inserted first will be removed at last. Think of it as the stack of plates stacked on top of one another where we can only add or remove the top plate.</p>"},{"location":"Notes/Stack.html#stack-is-fist-in-first-out-lifo","title":"Stack Is Fist In First Out ( LIFO )","text":""},{"location":"Notes/Stack.html#visualization","title":"Visualization","text":""},{"location":"Notes/Stack.html#operations","title":"Operations","text":"<ul> <li>Is Full: Check if the stack is full.</li> <li>Is Empty: Check if the stack is empty.</li> <li>Pop: Remove the top element from the stack.</li> <li>Push: Add an element to the top of the stack.</li> <li>Display: Display all the elements in the stack.</li> <li>Peek: Get the top element of the stack without removing it.</li> </ul>"},{"location":"Notes/Stack.html#time-complexity","title":"Time Complexity","text":"Operation Time Complexity Is Full O(1) Is Empty O(1) Pop O(1) Push O(1) Display O(n) Peek O(1) <p>Where n is the number of elements in the stack.</p>"},{"location":"Notes/Trees.html","title":"Trees","text":"<p>Tree Data Structure is a non-linear data structure in which a collection of elements known as nodes are connected to each other via edges such that there exists exactly one path between any two nodes.</p> <p></p>"},{"location":"Notes/Trees.html#binary-tree","title":"Binary Tree","text":"<p>A Binary Tree Data Structure is a hierarchical data structure in which each node has at most two children, referred to as the left child and the right child. It is commonly used in computer science for efficient storage and retrieval of data, with various operations such as insertion, deletion, and traversal.</p> <p>Here\u2019s your binary tree notes rewritten to be more descriptive, structured, and easy to read while keeping the technical depth intact:</p>"},{"location":"Notes/Trees.html#binary-tree-properties-notes","title":"Binary Tree Properties &amp; Notes","text":"<p>Note: In this convention, the height of the root node is considered 0. An empty tree (root = <code>NULL</code>) is considered to have height -1.</p>"},{"location":"Notes/Trees.html#1-maximum-nodes-at-a-given-level-l","title":"1. Maximum Nodes at a Given Level <code>l</code>","text":"<ul> <li>A binary tree can have at most $2^l$ nodes at level l.</li> <li> <p>Level Definition: The number of edges in the path from the root to a node.</p> </li> <li> <p>Root is at level 0.</p> </li> <li>Children of the root are at level 1, and so on.</li> </ul> <p>Proof (by induction):</p> <ol> <li>Base Case: Level $l = 0$ \u2192 $2^0 = 1$ node (only the root).</li> <li>Inductive Step:    If level <code>l</code> has $2^l$ nodes, then each node can have up to 2 children, making the next level:</li> </ol> <p>$$    2 \\times 2^l = 2^{l+1}    $$</p>"},{"location":"Notes/Trees.html#2-maximum-nodes-in-a-binary-tree-of-height-h","title":"2. Maximum Nodes in a Binary Tree of Height <code>h</code>","text":"<ul> <li>A binary tree of height <code>h</code> can have at most:</li> </ul> <p>$$ \\text{Max Nodes} = 2^{h+1} - 1 $$</p> <p>Height Definition:</p> <ul> <li>Height is the number of edges in the longest path from the root to a leaf.</li> <li>A tree with one root node only has height <code>0</code>.</li> <li>An empty tree has height <code>-1</code>.</li> </ul> <p>Derivation: When all levels are completely filled:</p> <p>$$ 1 + 2 + 4 + \\dots + 2^h = 2^{h+1} - 1 $$</p> <p>Alternate Height Convention: Some books define height differently:</p> <ul> <li>Tree with one root node \u2192 height = 1</li> <li>Empty tree \u2192 height = 0   Then, the formula becomes:</li> </ul> <p>$$ \\text{Max Nodes} = 2^h - 1 $$</p>"},{"location":"Notes/Trees.html#3-minimum-height-for-n-nodes","title":"3. Minimum Height for <code>N</code> Nodes","text":"<ul> <li>The minimum possible height for <code>N</code> nodes:</li> </ul> <p>$$ h_{\\min} = \\lfloor \\log_2 N \\rfloor $$</p> <p>Explanation: From the max nodes formula:</p> <p>$$ N \\le 2^{h+1} - 1 $$</p> <p>Rearranging:</p> <p>$$ h \\ge \\log_2(N + 1) - 1 $$</p> <p>Taking the floor gives:</p> <p>$$ h_{\\min} = \\lfloor \\log_2 N \\rfloor $$</p>"},{"location":"Notes/Trees.html#4-minimum-levels-for-l-leaves","title":"4. Minimum Levels for <code>L</code> Leaves","text":"<ul> <li>A binary tree with <code>L</code> leaves must have at least:</li> </ul> <p>$$ l_{\\min} = \\lfloor \\log_2 L \\rfloor $$</p> <p>Reason:</p> <ul> <li>Max leaves occur when the last level is completely filled.</li> <li>From Property 1:</li> </ul> <p>$$ L \\le 2^l $$</p> <p>Solving for <code>l</code>:</p> <p>$$ l_{\\min} = \\lfloor \\log_2 L \\rfloor $$</p>"},{"location":"Notes/Trees.html#5-relation-between-nodes-with-two-children-and-leaf-nodes","title":"5. Relation Between Nodes with Two Children and Leaf Nodes","text":"<p>In a full binary tree (every node has 0 or 2 children):</p> <p>$$ L = T + 1 $$</p> <p>Where:</p> <ul> <li><code>L</code> = number of leaf nodes</li> <li><code>T</code> = number of nodes with two children</li> </ul> <p>Proof:</p> <ul> <li>Full binary tree with height <code>h</code> has:</li> </ul> <p>$$   \\text{Total Nodes} = 2^{h+1} - 1   $$ * Leaves at the last level:</p> <p>$$   L = 2^h   $$ * Internal nodes:</p> <p>$$   T = (2^{h+1} - 1) - 2^h = 2^h - 1   $$</p> <p>Thus:</p> <p>$$ L = T + 1 $$</p>"},{"location":"Notes/Trees.html#6-total-edges-in-a-binary-tree","title":"6. Total Edges in a Binary Tree","text":"<ul> <li>Any non-empty binary tree with <code>n</code> nodes has exactly:</li> </ul> <p>$$ \\text{Edges} = n - 1 $$</p> <p>Reason:</p> <ul> <li>Every node (except the root) has exactly one parent \u2192 one incoming edge.</li> <li>Therefore, <code>n - 1</code> edges connect <code>n</code> nodes.</li> </ul>"},{"location":"Notes/Trees.html#node-types","title":"Node Types","text":"<ul> <li>Leaf Node: 0 children</li> <li>Unary Node: 1 child</li> <li>Binary Node: 2 children</li> </ul>"},{"location":"Notes/Trees.html#common-binary-tree-types","title":"Common Binary Tree Types","text":"<ul> <li>Full Binary Tree: Every non-leaf node has exactly two children.</li> <li>Complete Binary Tree: All levels filled except possibly the last, which is filled from left to right.</li> <li>Perfect Binary Tree: All levels completely filled; all leaves at the same depth.</li> <li>Balanced Binary Tree: Height difference between left and right subtrees \u2264 1 for every node.</li> </ul>"}]}